{"ast":null,"code":"var _jsxFileName = \"/home/jd/git/CrowdRec/src/components/SpotifyForm.js\";\nimport { withRouter } from 'react-router-dom';\nimport React, { Component } from 'react';\nimport { Card, Form, Button, Alert, Row } from 'react-bootstrap';\nimport { connect } from 'react-redux';\nimport SpotifyWebApi from 'spotify-web-api-js';\nimport Text from './Text';\nconst spotify = new SpotifyWebApi();\n\nclass SpotifyForm extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      resultReceived: false,\n      recOutput: {},\n      errorStatus: undefined\n    };\n    this.handleChange = this.handleChange.bind(this);\n    this.handleSubmit = this.handleSubmit.bind(this);\n    this.processResults = this.processResults.bind(this);\n    this.getRecs = this.getRecs.bind(this);\n    this.createPlaylist = this.createPlaylist.bind(this);\n    this.countTracks = this.countTracks.bind(this);\n    this.getRandomTrack = this.getRandomTrack.bind(this);\n  }\n  /**\n   * Runs after component mounts,  decodes the access token if applicable\n   */\n\n\n  componentDidMount() {\n    const hash = window.location.hash.substring(1).split('&').reduce(function (initial, item) {\n      if (item) {\n        var parts = item.split('=');\n        initial[parts[0]] = decodeURIComponent(parts[1]);\n      }\n\n      return initial;\n    }, {});\n    const access_token = hash.access_token;\n    this.props.change({\n      'name': 'token',\n      'value': access_token\n    });\n  }\n  /**\n     * Handle change in the artist value\n     * @param {Object} event Event incurred by change\n     */\n\n\n  handleChange(event) {\n    this.setState({\n      resultReceived: false,\n      alert: undefined\n    });\n    const {\n      target\n    } = event;\n    const {\n      value\n    } = target;\n    const {\n      name\n    } = target;\n    this.setState({\n      [name]: value\n    });\n    this.render();\n  }\n  /**\n     * Handle HTTP errors encountered by updating the state with an error message\n     * @param {Object} err\n     */\n\n\n  async handleError(err) {\n    switch (err.status) {\n      case 401:\n        this.setState({\n          errorStatus: 'You don\\'t seem to be authorized. Try clicking the button above to authorize with Spotify and try again.',\n          resultReceived: false\n        });\n        break;\n\n      case 429:\n        this.setState({\n          errorStatus: 'Looks like we\\'re making too many requests to Spotify right now. Wait a little bit and try that again.'\n        });\n        break;\n\n      case 501:\n        this.setState({\n          errorStatus: 'Spotify\\'s servers are fried! Check out their status, then try again when they\\'re back up'\n        });\n        break;\n\n      default:\n        console.log(err);\n    }\n  }\n  /**\n     * Checks whether a playlist contains is valid. Criteria for validity are:\n     *  - playlist attributes are well-defined (no null properties)\n     *  - playlist must contain the artist for which user is searching\n     * @param {string} id ID of playlist\n     * @param {*} artist Name of artist\n     * @return {Promise<boolean>} true if playlist is valid, false otherwise\n     */\n\n\n  async isPlaylistValid(id, artist) {\n    return spotify.getPlaylistTracks(id).then(pt => {\n      if (pt === undefined) {\n        return;\n      }\n\n      for (const track of pt.items) {\n        if (track === undefined || track.track === null) {\n          continue;\n        } else if (track.track.artists[0].name === artist) {\n          return true;\n        }\n      }\n\n      return false;\n    });\n  }\n  /**\n     * Asynchronously counts tracks by a given artist in a given playlist\n     * @param {string} id ID of the playlist\n     * @param {string} name Name of the artist\n     * @param {object} output Reference to output object which should be modified\n     * @return {Promise}\n     */\n\n\n  async countTracks(id, name, output) {\n    const MAX_SONGS = 200;\n    return spotify.getPlaylistTracks(id).then(pt => {\n      let curSongs = 0;\n\n      for (const track of pt.items) {\n        if (curSongs > MAX_SONGS) break;\n\n        if (track.track != null && track.track.artists[0].name !== name && track.track.artists[0].name !== '') {\n          if (track.track.artists[0].name in output) {\n            output[track.track.artists[0].name]++;\n          } else {\n            output[track.track.artists[0].name] = 1;\n          }\n        }\n\n        curSongs++;\n      }\n    }).catch(err => {\n      if (err.status === 429) {\n        setTimeout(this.countTracks(id, name, output), 500);\n      }\n\n      this.handleError(err);\n    });\n  }\n  /**\n     * Gets recommendations for a specific artist and outputs recOutput value in state\n     * @param {string} name The name of the artist\n     * @return {Promise}\n     * /\n    * */\n\n\n  async getRecs(name) {\n    const output = {};\n    const promises = [];\n    await spotify.searchPlaylists(name, {\n      limit: 1\n    }).then(async searchTotal => await spotify.searchPlaylists(name, {\n      limit: 50,\n      offset: Math.floor(Math.random() * (searchTotal.playlists.total / 50))\n    }).then(res => {\n      for (const i of res.playlists.items) {\n        promises.push(this.isPlaylistValid(i.id, name).then(valid => valid ? this.countTracks(i.id, name, output) : null));\n      }\n    })).catch(err => {\n      this.handleError(err);\n    });\n    return Promise.all(promises).then(() => this.setState({\n      recOutput: this.processResults(output),\n      artist: name\n    }));\n  }\n  /**\n     * Processesresults from our query to spotify, removing entries beyond a certain threshhold then sorting the object.\n     * @return Results\n     */\n\n\n  processResults(input) {\n    const processed = {};\n\n    for (const key in input) {\n      if (input[key] > 10) {\n        processed[key] = input[key];\n      }\n    }\n\n    const sorted = Object.fromEntries(Object.entries(processed).sort(([, a], [, b]) => b - a));\n    return sorted;\n  }\n  /**\n   * Gets a random track for a given band. \n   * @param {string} band \n   */\n\n\n  getRandomTrack(band) {\n    return spotify.searchTracks(band, {\n      limit: 1\n    }).then(searchTotal => spotify.searchTracks(band, {\n      limit: 50\n    })).then(tracks => {\n      if (tracks === undefined || tracks.tracks === null) {\n        return this.getRandomTrack(band);\n      } // filter so we only get songs by the artist\n\n\n      let filteredByBand = tracks.tracks.items.filter(song => song.artists[0].name === band);\n      return filteredByBand[Math.floor(Math.random() * filteredByBand.length)];\n    }).catch(err => {\n      if (err.status === 429) {\n        setTimeout(() => console.log(\"waiting to prevent 429...\"), 500);\n        return this.getRandomTrack(band);\n      } else {\n        this.handleError(err);\n      }\n    });\n  }\n  /**\n     * Creates playlist with one random song from each output artist\n     */\n\n\n  createPlaylist() {\n    const promises = [];\n    const trackUris = [];\n    Object.keys(this.state.recOutput).forEach(async artist => {\n      promises.push(this.getRandomTrack(artist).then(track => trackUris.push(track.uri)).catch(err => this.handleError(err)));\n    }); // this.setState({playlistUrl: playlist.external_urls[\"spotify\"]})\n\n    Promise.all(promises).then(() => {\n      if (this.state.errorStatus === undefined) {\n        const addPromises = [];\n        spotify.getMe().then(me => spotify.createPlaylist(me.id, {\n          name: `Recommendations Based on  ${this.state.artist}`,\n          public: false\n        })).then(playlist => {\n          trackUris.forEach(uri => addPromises.push(spotify.addTracksToPlaylist(playlist.id, [uri]).catch(err => {\n            if (err.status === 429) {\n              setTimeout(() => console.log(\"waiting to prevent 429...\"), 500);\n              return spotify.addTracksToPlaylist(playlist.id, [uri]);\n            } else {\n              this.handleError(err);\n            }\n          })));\n          this.setState({\n            playlistUrl: playlist.external_urls.spotify\n          });\n        });\n        Promise.all(addPromises).then(() => this.setState({\n          playlistCreated: true\n        }));\n      }\n    });\n  }\n  /**\n     *  Handles submission of Artist form\n     * @param {Object} e Submission event\n     * \n     */\n\n\n  handleSubmit(e) {\n    e.preventDefault();\n    spotify.setAccessToken(this.props.vars.token);\n    this.setState({\n      errorStatus: undefined,\n      alert: undefined\n    });\n    spotify.searchArtists(this.state.artist).then(async res => await this.getRecs(res.artists.items[0].name)).then(() => {\n      // Only show recommendations if they're non empty\n      if (this.state.errorStatus === undefined) {\n        if (Object.keys(this.state.recOutput).length === 0) {\n          this.setState({\n            errorStatus: 'Unfortunately, we could not find any recommendations for that artist at this time. Feel free to try another one, or try again since recommendations are randomly generated.'\n          });\n        } else {\n          this.setState({\n            resultReceived: true\n          });\n        }\n      }\n    }).catch(err => {\n      if (err.status === 429) {\n        setTimeout(() => console.log(\"waiting to prevent 429...\"), 500);\n        return this.handleSubmit(e);\n      }\n\n      this.handleError(err);\n    });\n  }\n  /**\n     * Render the component\n     * @return JSX\n     */\n\n\n  render() {\n    return /*#__PURE__*/React.createElement(React.Fragment, null, this.state.alert !== undefined ? /*#__PURE__*/React.createElement(Alert, {\n      className: \"alert-success\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 300,\n        columnNumber: 11\n      }\n    }, /*#__PURE__*/React.createElement(Text, {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 301,\n        columnNumber: 13\n      }\n    }, this.state.alert, /*#__PURE__*/React.createElement(\"br\", {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 303,\n        columnNumber: 15\n      }\n    }), /*#__PURE__*/React.createElement(\"a\", {\n      href: this.state.playlistUrl,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 304,\n        columnNumber: 15\n      }\n    }, this.state.playlistUrl))) : null, this.state.errorStatus !== undefined ? /*#__PURE__*/React.createElement(Alert, {\n      className: \"alert-danger\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 309,\n        columnNumber: 9\n      }\n    }, /*#__PURE__*/React.createElement(Text, {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 310,\n        columnNumber: 11\n      }\n    }, this.state.errorStatus)) : null, /*#__PURE__*/React.createElement(\"h1\", {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 313,\n        columnNumber: 13\n      }\n    }, \"Enter artist's name for recommendations\"), /*#__PURE__*/React.createElement(Form, {\n      onSubmit: this.handleSubmit,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 314,\n        columnNumber: 13\n      }\n    }, /*#__PURE__*/React.createElement(Form.Group, {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 315,\n        columnNumber: 15\n      }\n    }, /*#__PURE__*/React.createElement(Form.Label, {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 316,\n        columnNumber: 17\n      }\n    }, \"Artist\"), /*#__PURE__*/React.createElement(Form.Control, {\n      type: \"text\",\n      placeholder: \"Iron Maiden\",\n      name: \"artist\",\n      onChange: this.handleChange,\n      required: true,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 317,\n        columnNumber: 17\n      }\n    })), /*#__PURE__*/React.createElement(Form.Group, {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 319,\n        columnNumber: 15\n      }\n    }, /*#__PURE__*/React.createElement(Form.Control, {\n      type: \"submit\",\n      className: \"bg-primary text-light\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 320,\n        columnNumber: 17\n      }\n    })), /*#__PURE__*/React.createElement(Form.Group, {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 322,\n        columnNumber: 15\n      }\n    }, /*#__PURE__*/React.createElement(Form.Control, {\n      type: \"reset\",\n      className: \"bg-primary text-light\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 323,\n        columnNumber: 17\n      }\n    }))), /*#__PURE__*/React.createElement(\"div\", {\n      className: \"d-block\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 327,\n        columnNumber: 9\n      }\n    }, this.state.resultReceived ? /*#__PURE__*/React.createElement(\"h4\", {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 329,\n        columnNumber: 13\n      }\n    }, \"Recommended Artists for \", this.state.artist) : null, /*#__PURE__*/React.createElement(Row, {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 333,\n        columnNumber: 11\n      }\n    }, /*#__PURE__*/React.createElement(\"ul\", {\n      className: \"col-6\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 334,\n        columnNumber: 13\n      }\n    }, this.state.resultReceived ? Object.keys(this.state.recOutput).map(band => /*#__PURE__*/React.createElement(Card, {\n      className: \"text-center border mb-2\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 336,\n        columnNumber: 17\n      }\n    }, band, \":\", ' ', this.state.recOutput[band])) : null), this.state.resultReceived ? this.state.playlistCreated ? /*#__PURE__*/React.createElement(Button, {\n      className: \"bg-success mt-3 col-6 w-50\",\n      onClick: () => {\n        window.location.href = this.state.playlistUrl;\n      },\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 346,\n        columnNumber: 15\n      }\n    }, \" Playlist created! Click below to open it up.\") : /*#__PURE__*/React.createElement(Button, {\n      className: \"mt-3 col-6 h-50 w-50\",\n      onClick: this.createPlaylist,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 347,\n        columnNumber: 15\n      }\n    }, \"Create a playlist with songs from these artists\") : null)));\n  }\n\n} // mapping our redux state to box props\n\n\nconst mapStateToProps = state => ({\n  vars: state.vars\n}); // mapping the dispatches from our reducer to box props\n\n\nconst mapDispatchToProps = dispatch => ({\n  change: vName => dispatch({\n    type: 'CHANGE',\n    name: vName\n  })\n});\n\nexport default withRouter(connect(mapStateToProps, mapDispatchToProps)(SpotifyForm));","map":{"version":3,"sources":["/home/jd/git/CrowdRec/src/components/SpotifyForm.js"],"names":["withRouter","React","Component","Card","Form","Button","Alert","Row","connect","SpotifyWebApi","Text","spotify","SpotifyForm","constructor","props","state","resultReceived","recOutput","errorStatus","undefined","handleChange","bind","handleSubmit","processResults","getRecs","createPlaylist","countTracks","getRandomTrack","componentDidMount","hash","window","location","substring","split","reduce","initial","item","parts","decodeURIComponent","access_token","change","event","setState","alert","target","value","name","render","handleError","err","status","console","log","isPlaylistValid","id","artist","getPlaylistTracks","then","pt","track","items","artists","output","MAX_SONGS","curSongs","catch","setTimeout","promises","searchPlaylists","limit","searchTotal","offset","Math","floor","random","playlists","total","res","i","push","valid","Promise","all","input","processed","key","sorted","Object","fromEntries","entries","sort","a","b","band","searchTracks","tracks","filteredByBand","filter","song","length","trackUris","keys","forEach","uri","addPromises","getMe","me","public","playlist","addTracksToPlaylist","playlistUrl","external_urls","playlistCreated","e","preventDefault","setAccessToken","vars","token","searchArtists","map","href","mapStateToProps","mapDispatchToProps","dispatch","vName","type"],"mappings":"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","sourcesContent":["import {withRouter} from 'react-router-dom';\nimport React, {Component} from 'react';\nimport {\n  Card, Form, Button, Alert, Row\n} from 'react-bootstrap';\nimport {connect} from 'react-redux';\nimport SpotifyWebApi from 'spotify-web-api-js';\nimport Text from './Text';\n\nconst spotify = new SpotifyWebApi();\n\n\nclass SpotifyForm extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {resultReceived: false, recOutput: {}, errorStatus: undefined};\n    this.handleChange = this.handleChange.bind(this);\n    this.handleSubmit = this.handleSubmit.bind(this);\n    this.processResults = this.processResults.bind(this);\n    this.getRecs = this.getRecs.bind(this);\n    this.createPlaylist = this.createPlaylist.bind(this);\n    this.countTracks = this.countTracks.bind(this);\n    this.getRandomTrack = this.getRandomTrack.bind(this);\n  }\n\n  /**\n   * Runs after component mounts,  decodes the access token if applicable\n   */\n  componentDidMount() {\n    const hash = window.location.hash\n    .substring(1)\n    .split('&')\n    .reduce(function (initial, item) {\n      if (item) {\n        var parts = item.split('=');\n        initial[parts[0]] = decodeURIComponent(parts[1]);\n      }\n      return initial;\n    }, {});\n\n    const access_token = hash.access_token;\n    this.props.change({'name': 'token', 'value': access_token})\n    \n    \n  }\n\n  /**\n     * Handle change in the artist value\n     * @param {Object} event Event incurred by change\n     */\n  handleChange(event) {\n    this.setState({resultReceived: false, alert: undefined});\n    const {target} = event;\n    const {value} = target;\n    const {name} = target;\n    this.setState({[name]: value});\n    this.render();\n  }\n\n  /**\n     * Handle HTTP errors encountered by updating the state with an error message\n     * @param {Object} err\n     */\n  async handleError(err) {\n    switch (err.status) {\n      case 401:\n        this.setState({errorStatus: 'You don\\'t seem to be authorized. Try clicking the button above to authorize with Spotify and try again.', resultReceived: false});\n        break;\n      case 429:\n        this.setState({errorStatus: 'Looks like we\\'re making too many requests to Spotify right now. Wait a little bit and try that again.'});\n        break;\n      case 501:\n        this.setState({errorStatus: 'Spotify\\'s servers are fried! Check out their status, then try again when they\\'re back up'});\n        break;\n      default:\n        console.log(err);\n    }\n  }\n\n  /**\n     * Checks whether a playlist contains is valid. Criteria for validity are:\n     *  - playlist attributes are well-defined (no null properties)\n     *  - playlist must contain the artist for which user is searching\n     * @param {string} id ID of playlist\n     * @param {*} artist Name of artist\n     * @return {Promise<boolean>} true if playlist is valid, false otherwise\n     */\n  async isPlaylistValid(id, artist) {\n    return spotify.getPlaylistTracks(id)\n        .then(\n            (pt) => {\n              if (pt === undefined) {\n                return;\n              }\n              for (const track of pt.items) {\n                if (track === undefined || track.track === null) {\n                  continue;\n                } else if (track.track.artists[0].name === artist) {\n                  return true;\n                }\n              }\n              return false;\n            },\n        );\n  }\n\n  /**\n     * Asynchronously counts tracks by a given artist in a given playlist\n     * @param {string} id ID of the playlist\n     * @param {string} name Name of the artist\n     * @param {object} output Reference to output object which should be modified\n     * @return {Promise}\n     */\n  async countTracks(id, name, output) {\n    const MAX_SONGS = 200;\n    return spotify.getPlaylistTracks(id).then(\n        (pt) => {\n          let curSongs = 0;\n          for (const track of pt.items) {\n            if (curSongs > MAX_SONGS) break;\n            if (track.track != null &&\n                        track.track.artists[0].name !== name &&\n                        track.track.artists[0].name !== '') {\n              if (track.track.artists[0].name in output) {\n                output[track.track.artists[0].name]++;\n              } else {\n                output[track.track.artists[0].name] = 1;\n              }\n            }\n            curSongs++;\n          }\n        },\n    ).catch((err) => {\n        if (err.status === 429) {\n            setTimeout(this.countTracks(id, name, output), 500);\n        } \n        this.handleError(err)\n    });\n  }\n\n  /**\n     * Gets recommendations for a specific artist and outputs recOutput value in state\n     * @param {string} name The name of the artist\n     * @return {Promise}\n     * /\n    * */\n  async getRecs(name) {\n    const output = {};\n\n    const promises = [];\n    await spotify.searchPlaylists(name, {limit: 1})\n        .then(async (searchTotal) => await spotify.searchPlaylists(name, {limit: 50, offset: Math.floor(Math.random() * (searchTotal.playlists.total / 50))}).then(\n            (res) => {\n              for (const i of res.playlists.items) {\n                promises.push(this.isPlaylistValid(i.id, name)\n                    .then((valid) => (valid ? this.countTracks(i.id, name, output) : null)));\n              }\n            },\n        )).catch((err) => {\n                this.handleError(err)\n        });\n\n    return Promise.all(promises).then(() => this.setState({recOutput: this.processResults(output), artist: name}));\n  }\n\n  /**\n     * Processesresults from our query to spotify, removing entries beyond a certain threshhold then sorting the object.\n     * @return Results\n     */\n  processResults(input) {\n    const processed = {};\n    for (const key in input) {\n      if (input[key] > 10) {\n        processed[key] = input[key];\n      }\n    }\n    const sorted = Object.fromEntries(\n        Object.entries(processed).sort(([, a], [, b]) => b - a),\n    );\n    return sorted;\n  }\n\n  /**\n   * Gets a random track for a given band. \n   * @param {string} band \n   */\n  getRandomTrack(band) {\n    return spotify.searchTracks(band, {limit: 1})\n        .then((searchTotal) => spotify.searchTracks(band, {limit: 50}))\n        .then(\n            (tracks) => {\n              if (tracks === undefined || tracks.tracks === null) {\n                  return this.getRandomTrack(band);\n              }\n              // filter so we only get songs by the artist\n              let filteredByBand = tracks.tracks.items.filter(song =>\n                song.artists[0].name === band\n              )\n\n              return filteredByBand[Math.floor(Math.random() * filteredByBand.length)];\n            },\n        ).catch(err => { \n            \n            if (err.status === 429) {\n                setTimeout(() => console.log(\"waiting to prevent 429...\"), 500)\n                return this.getRandomTrack(band)\n            } else {\n                this.handleError(err);\n            } \n            \n             \n        })\n  }\n\n  /**\n     * Creates playlist with one random song from each output artist\n     */\n  createPlaylist() {\n    const promises = [];\n    const trackUris = [];\n\n    Object.keys(this.state.recOutput).forEach(async (artist) => {\n      promises.push(\n              this.getRandomTrack(artist)\n              .then((track) => trackUris.push(track.uri))\n              .catch((err) => this.handleError(err)\n      ));\n    });\n\n    // this.setState({playlistUrl: playlist.external_urls[\"spotify\"]})\n    Promise.all(promises).then(() => {\n      if (this.state.errorStatus === undefined) {\n        const addPromises = [];\n        spotify.getMe()\n            .then((me) => spotify.createPlaylist(me.id, {name: `Recommendations Based on  ${this.state.artist}`, public: false}))\n            .then((playlist) => {\n              trackUris.forEach(\n                  (uri) => addPromises.push(\n                      spotify.addTracksToPlaylist(playlist.id, [uri])\n                      .catch(err => {\n                        if (err.status === 429) {\n                            setTimeout(() => console.log(\"waiting to prevent 429...\"), 500)\n                            return spotify.addTracksToPlaylist(playlist.id, [uri]);\n                        } else {\n                            this.handleError(err);\n                        }\n                        \n                      })\n                      \n                    )\n              );\n              this.setState({playlistUrl: playlist.external_urls.spotify});\n            });\n        Promise.all(addPromises).then(() => this.setState({playlistCreated: true}));\n      }\n    });\n  }\n\n  /**\n     *  Handles submission of Artist form\n     * @param {Object} e Submission event\n     * \n     */\n  handleSubmit(e) {\n    e.preventDefault();\n    spotify.setAccessToken(this.props.vars.token);\n    this.setState({errorStatus: undefined, alert: undefined});\n    spotify.searchArtists(this.state.artist)\n        .then(async (res) => await this.getRecs(res.artists.items[0].name))\n        .then(() => {\n        // Only show recommendations if they're non empty\n          if (this.state.errorStatus === undefined) {\n            if (Object.keys(this.state.recOutput).length === 0) {\n              this.setState(\n                  {errorStatus: 'Unfortunately, we could not find any recommendations for that artist at this time. Feel free to try another one, or try again since recommendations are randomly generated.'},\n              );\n            } else {\n              this.setState({resultReceived: true});\n            }\n          }\n        })\n        .catch((err) => {\n            if (err.status === 429) {\n                setTimeout(() => console.log(\"waiting to prevent 429...\"), 500)\n                return this.handleSubmit(e);\n            } \n            this.handleError(err)}\n        );\n  }\n\n\n  /**\n     * Render the component\n     * @return JSX\n     */\n  render() {\n    return (\n      <>\n        {this.state.alert !== undefined ? (\n          <Alert className=\"alert-success\">\n            <Text>\n              {this.state.alert}\n              <br />\n              <a href={this.state.playlistUrl}>{this.state.playlistUrl}</a>\n            </Text>\n          </Alert>\n        ) : null }\n        {this.state.errorStatus !== undefined ? \n        <Alert className=\"alert-danger\">\n          <Text>{this.state.errorStatus}</Text>\n        </Alert>\n         : null }\n            <h1>Enter artist's name for recommendations</h1>\n            <Form onSubmit={this.handleSubmit}>\n              <Form.Group>\n                <Form.Label>Artist</Form.Label>\n                <Form.Control type=\"text\" placeholder=\"Iron Maiden\" name=\"artist\" onChange={this.handleChange} required />\n              </Form.Group>\n              <Form.Group>\n                <Form.Control type=\"submit\" className=\"bg-primary text-light\" />\n              </Form.Group>\n              <Form.Group>\n                <Form.Control type=\"reset\" className=\"bg-primary text-light\" />\n              </Form.Group>\n            </Form>\n\n        <div className=\"d-block\">\n          {this.state.resultReceived ? (\n            <h4>\n              Recommended Artists for {this.state.artist}\n            </h4>\n          ) : null }\n          <Row>\n            <ul className=\"col-6\">\n              {this.state.resultReceived ? Object.keys(this.state.recOutput).map((band) => (\n                <Card className=\"text-center border mb-2\">\n                  {band}\n                  :\n                  {' '}\n                  {this.state.recOutput[band]}\n                </Card>\n              )) : null }\n            </ul>\n            {this.state.resultReceived ? \n              this.state.playlistCreated ?\n              <Button className=\"bg-success mt-3 col-6 w-50\"onClick={ () => {window.location.href = this.state.playlistUrl;} }> Playlist created! Click below to open it up.</Button> :\n              <Button className=\"mt-3 col-6 h-50 w-50\" onClick={this.createPlaylist}>Create a playlist with songs from these artists</Button> : \n              null\n              }\n          </Row>\n        </div>\n\n      </>\n\n\n    );\n  }\n}\n\n// mapping our redux state to box props\nconst mapStateToProps = (state) => ({\n  vars: state.vars,\n});\n\n// mapping the dispatches from our reducer to box props\nconst mapDispatchToProps = (dispatch) => ({\n  change: (vName) => dispatch({type: 'CHANGE', name: vName}),\n\n});\n\nexport default withRouter(connect(mapStateToProps, mapDispatchToProps)(SpotifyForm));\n"]},"metadata":{},"sourceType":"module"}